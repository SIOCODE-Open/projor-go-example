{
  "generatedSource": [
    {
      "filename": "main.go",
      "content": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"encoding/json\"\n)\n\nvar (\n    userAccountRepository = NewUserAccountRepository()\n    productRepository = NewProductRepository()\n)\n\nfunc HandleUserAccountCreate(w http.ResponseWriter, r *http.Request) {\n    userAccount := &UserAccount{}\n    if err := json.NewDecoder(r.Body).Decode(userAccount); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    if err := userAccountRepository.Create(userAccount); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusCreated)\n}\n\nfunc HandleUserAccountUpdate(w http.ResponseWriter, r *http.Request) {\n    userAccount := &UserAccount{}\n    if err := json.NewDecoder(r.Body).Decode(userAccount); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    if err := userAccountRepository.Update(userAccount); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n}\n\nfunc HandleUserAccountDelete(w http.ResponseWriter, r *http.Request) {\n    userAccount := &UserAccount{}\n    if err := json.NewDecoder(r.Body).Decode(userAccount); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    if err := userAccountRepository.Delete(userAccount); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n}\n\nfunc HandleUserAccountGetByID(w http.ResponseWriter, r *http.Request) {\n    id := r.URL.Path[len(\"/user-account/\"):]\n    userAccount, err := userAccountRepository.GetByID(id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusNotFound)\n        return\n    }\n    if err := json.NewEncoder(w).Encode(userAccount); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n}\n\nfunc HandleUserAccountGetAll(w http.ResponseWriter, r *http.Request) {\n    userAccounts, err := userAccountRepository.GetAll()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    if err := json.NewEncoder(w).Encode(userAccounts); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n}\n\nfunc HandleUserAccountRequest(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n    w.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n    w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Accept\")\n    switch r.Method {\n    case http.MethodOptions:\n        w.WriteHeader(http.StatusOK)\n        w.Header().Set(\"Allow\", \"GET, POST, PUT, DELETE, OPTIONS\")\n    case http.MethodPost:\n        HandleUserAccountCreate(w, r)\n    case http.MethodPut:\n        HandleUserAccountUpdate(w, r)\n    case http.MethodDelete:\n        HandleUserAccountDelete(w, r)\n    case http.MethodGet:\n        if r.URL.Path == \"/user-account\" {\n            HandleUserAccountGetAll(w, r)\n        } else {\n            HandleUserAccountGetByID(w, r)\n        }\n    default:\n        http.Error(w, fmt.Sprintf(\"Method %s not allowed\", r.Method), http.StatusMethodNotAllowed)\n    }\n}\nfunc HandleProductCreate(w http.ResponseWriter, r *http.Request) {\n    product := &Product{}\n    if err := json.NewDecoder(r.Body).Decode(product); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    if err := productRepository.Create(product); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusCreated)\n}\n\nfunc HandleProductUpdate(w http.ResponseWriter, r *http.Request) {\n    product := &Product{}\n    if err := json.NewDecoder(r.Body).Decode(product); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    if err := productRepository.Update(product); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n}\n\nfunc HandleProductDelete(w http.ResponseWriter, r *http.Request) {\n    product := &Product{}\n    if err := json.NewDecoder(r.Body).Decode(product); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    if err := productRepository.Delete(product); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n}\n\nfunc HandleProductGetByID(w http.ResponseWriter, r *http.Request) {\n    id := r.URL.Path[len(\"/product/\"):]\n    product, err := productRepository.GetByID(id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusNotFound)\n        return\n    }\n    if err := json.NewEncoder(w).Encode(product); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n}\n\nfunc HandleProductGetAll(w http.ResponseWriter, r *http.Request) {\n    products, err := productRepository.GetAll()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    if err := json.NewEncoder(w).Encode(products); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n}\n\nfunc HandleProductRequest(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n    w.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n    w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Accept\")\n    switch r.Method {\n    case http.MethodOptions:\n        w.WriteHeader(http.StatusOK)\n        w.Header().Set(\"Allow\", \"GET, POST, PUT, DELETE, OPTIONS\")\n    case http.MethodPost:\n        HandleProductCreate(w, r)\n    case http.MethodPut:\n        HandleProductUpdate(w, r)\n    case http.MethodDelete:\n        HandleProductDelete(w, r)\n    case http.MethodGet:\n        if r.URL.Path == \"/product\" {\n            HandleProductGetAll(w, r)\n        } else {\n            HandleProductGetByID(w, r)\n        }\n    default:\n        http.Error(w, fmt.Sprintf(\"Method %s not allowed\", r.Method), http.StatusMethodNotAllowed)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/user-account\", HandleUserAccountRequest)\n    http.HandleFunc(\"/product\", HandleProductRequest)\n\n    fmt.Println(\"Server running on port 8080\")\n    http.ListenAndServe(\":8080\", nil)\n}",
      "contentHash": "27fa18541a85720c783948206f2a45c35c8a0565576c1ff0c56898f95ca1e001",
      "noWriteIfExists": false
    },
    {
      "filename": "product.go",
      "content": "package main\n\nimport \"errors\"\n\ntype Product struct {\n    Id string `json:\"id\"`\n    Name string `json:\"name\"`\n    Price float32 `json:\"price\"`\n    Description string `json:\"description\"`\n}\n\ntype IProductRepository interface {\n    Create(product *Product) error\n    Update(product *Product) error\n    Delete(product *Product) error\n    GetByID(id string) (*Product, error)\n    GetAll() ([]Product, error)\n}\n\ntype ProductRepository struct {\n    IProductRepository\n    entities map[string]*Product\n}\n\nfunc NewProductRepository() *ProductRepository {\n    return &ProductRepository{\n        entities: make(map[string]*Product),\n    }\n}\n\nfunc (repo *ProductRepository) Create(product *Product) error {\n    if _, ok := repo.entities[product.Id]; ok {\n        return errors.New(\"Product already exists\")\n    }\n    repo.entities[product.Id] = product\n    return nil\n}\n\nfunc (repo *ProductRepository) Update(product *Product) error {\n    if _, ok := repo.entities[product.Id]; !ok {\n        return errors.New(\"Product not found\")\n    }\n    repo.entities[product.Id] = product\n    return nil\n}\n\nfunc (repo *ProductRepository) Delete(product *Product) error {\n    if _, ok := repo.entities[product.Id]; !ok {\n        return errors.New(\"Product not found\")\n    }\n    delete(repo.entities, product.Id)\n    return nil\n}\n\nfunc (repo *ProductRepository) GetByID(id string) (*Product, error) {\n    if _, ok := repo.entities[id]; !ok {\n        return nil, errors.New(\"Product not found\")\n    }\n    return repo.entities[id], nil\n}\n\nfunc (repo *ProductRepository) GetAll() ([]Product, error) {\n    var result []Product\n    for _, entity := range repo.entities {\n        result = append(result, *entity)\n    }\n    return result, nil\n}",
      "contentHash": "3cf032d63908787f9be8d0fe2e2bf4ab3f692a75279cc99d317230c24c2ec941",
      "noWriteIfExists": false
    },
    {
      "filename": "README.md",
      "content": "# ProJor Go Example\n\nThis repository contains the source code for the ProJor Go Example application. The repository uses [ProJor](https://docs.siocode.hu/projor), the model-based code generator to maintain most of the source code. See in the `.projor/` directory to examine the schema, model, and templates used to generate the code.\n\nThis example is documented [here](https://docs.siocode.hu/projor/full-examples/go).\n\n## Building\n\n* First, you must build the backend by running `go build`\n* Then, you must build the frontend by running `npm install` and `npm run build`\n\n## Running\n\n* First, start the backend by executing the built binary file (called `projor-go-example` or `projor-go-example.exe` on Windows)\n* Then, start the frontend by running `npm run dev`\n* Open your browser and navigate to `http://localhost:3000`\n* Use [Postman](https://www.postman.com/) to test the backend API (running on `http://localhost:8080`)\n\n## Documentation\n\n### User Account\n\nThe user accounts in the system\n\nFields:\n\n* `id` : `string` - Unique identifier of the UserAccount\n* `username` : `String` - The username of the user account\n* `email` : `String` - The email address of the user account\n* `flags` : `String` - The flags of the user account\n\n### Product\n\nThe products in the system\n\nFields:\n\n* `id` : `string` - Unique identifier of the Product\n* `name` : `String` - The name of the product\n* `price` : `Float32` - The price of the product\n* `description` : `String` - The description of the product\n\n",
      "contentHash": "1d5f277fcb179d2d1bb2d47352a6f183ed7eba75814f8c9aec26c65044d979ac",
      "noWriteIfExists": false
    },
    {
      "filename": "src/App.tsx",
      "content": "import { useEffect, useState } from 'react';\nimport {\n    IUserAccount,\n    IProduct,\n    IAppClient,\n    createAppClient\n} from \"./client\";\n\nconst appClient = createAppClient(\"http://localhost:8080\");\n\nfunction UserAccountTable(\n    props: {\n        value: Array<IUserAccount>\n    }\n) {\n    const tableRows = props.value.map(\n        (data) => (\n            <tr key={data.id}>\n                <td>{data.id}</td>\n                <td>{ data.username }</td>\n                <td>{ data.email }</td>\n                <td>{ data.flags }</td>\n            </tr>\n        )\n    );\n    return <table border=\"1\">\n        <thead>\n            <tr>\n                <th>Id</th>\n                <th>Username</th>\n                <th>Email</th>\n                <th>Flags</th>\n            </tr>\n        </thead>\n        <tbody>\n            {tableRows}\n        </tbody>\n    </table>;\n}\n\nfunction UserAccountCreateForm(\n    props: {\n        onCreated: () => void\n    }\n) {\n    const [id, setId] = useState(\"\");\n    const [username, setUsername] = useState(\n        \"\"\n    );\n    const [email, setEmail] = useState(\n        \"\"\n    );\n    const [flags, setFlags] = useState(\n        \"\"\n    );\n\n    const clearForm = () => {\n        setId(\"\");\n        setUsername(\n            \"\"\n        );\n        setEmail(\n            \"\"\n        );\n        setFlags(\n            \"\"\n        );\n    }\n\n    const onSave = async () => {\n        try {\n            await appClient.userAccount.create({\n                id,\n                username,\n                email,\n                flags: flags.split(\",\"),\n            });\n            props.onCreated();\n            clearForm();\n        } catch (error) {\n            console.error(error);\n        }\n    };\n\n    return <form>\n        <div>\n            <label>\n                Id\n            </label>\n            <input\n                type=\"text\"\n                value={id}\n                onChange={(e) => setId(e.target.value)}\n            />\n        </div>\n        <div>\n            <label>\n                Username\n            </label>\n            <input\n                type=\"text\"\n                value={ username }\n                onChange={(e) => setUsername(e.target.value)}\n            />\n        </div>\n        <div>\n            <label>\n                Email\n            </label>\n            <input\n                type=\"text\"\n                value={ email }\n                onChange={(e) => setEmail(e.target.value)}\n            />\n        </div>\n        <div>\n            <label>\n                Flags\n            </label>\n            <input\n                type=\"text\"\n                value={ flags }\n                onChange={(e) => setFlags(e.target.value)}\n            />\n        </div>\n        <button type=\"button\" onClick={onSave}>Save</button>\n    </form>;\n}\nfunction ProductTable(\n    props: {\n        value: Array<IProduct>\n    }\n) {\n    const tableRows = props.value.map(\n        (data) => (\n            <tr key={data.id}>\n                <td>{data.id}</td>\n                <td>{ data.name }</td>\n                <td>{ data.price }</td>\n                <td>{ data.description }</td>\n            </tr>\n        )\n    );\n    return <table border=\"1\">\n        <thead>\n            <tr>\n                <th>Id</th>\n                <th>Name</th>\n                <th>Price</th>\n                <th>Description</th>\n            </tr>\n        </thead>\n        <tbody>\n            {tableRows}\n        </tbody>\n    </table>;\n}\n\nfunction ProductCreateForm(\n    props: {\n        onCreated: () => void\n    }\n) {\n    const [id, setId] = useState(\"\");\n    const [name, setName] = useState(\n        \"\"\n    );\n    const [price, setPrice] = useState(\n        0.0\n    );\n    const [description, setDescription] = useState(\n        \"\"\n    );\n\n    const clearForm = () => {\n        setId(\"\");\n        setName(\n            \"\"\n        );\n        setPrice(\n            0.0\n        );\n        setDescription(\n            \"\"\n        );\n    }\n\n    const onSave = async () => {\n        try {\n            await appClient.product.create({\n                id,\n                name,\n                price,\n                description,\n            });\n            props.onCreated();\n            clearForm();\n        } catch (error) {\n            console.error(error);\n        }\n    };\n\n    return <form>\n        <div>\n            <label>\n                Id\n            </label>\n            <input\n                type=\"text\"\n                value={id}\n                onChange={(e) => setId(e.target.value)}\n            />\n        </div>\n        <div>\n            <label>\n                Name\n            </label>\n            <input\n                type=\"text\"\n                value={ name }\n                onChange={(e) => setName(e.target.value)}\n            />\n        </div>\n        <div>\n            <label>\n                Price\n            </label>\n            <input\n                type=\"text\"\n                value={ price }\n                onChange={(e) => setPrice(e.target.value)}\n            />\n        </div>\n        <div>\n            <label>\n                Description\n            </label>\n            <input\n                type=\"text\"\n                value={ description }\n                onChange={(e) => setDescription(e.target.value)}\n            />\n        </div>\n        <button type=\"button\" onClick={onSave}>Save</button>\n    </form>;\n}\n\nexport function App() {\n    const [userAccounts, setUserAccounts] = useState<Array<IUserAccount>>([]);\n    const [products, setProducts] = useState<Array<IProduct>>([]);\n\n    const populateUserAccounts = async () => {\n        try {\n            const data = await appClient.userAccount.getAll();\n            setUserAccounts(data || []);\n        } catch (error) {\n            console.error(error);\n        }\n    };\n    const populateProducts = async () => {\n        try {\n            const data = await appClient.product.getAll();\n            setProducts(data || []);\n        } catch (error) {\n            console.error(error);\n        }\n    };\n\n    useEffect(() => {\n        populateUserAccounts();\n        populateProducts();\n    }, []);\n\n    return (\n        <div>\n            <h2>UserAccount</h2>\n            <UserAccountTable value={ userAccounts } />\n            <UserAccountCreateForm onCreated={populateUserAccounts} />\n            <h2>Product</h2>\n            <ProductTable value={ products } />\n            <ProductCreateForm onCreated={populateProducts} />\n        </div>\n    );\n}",
      "contentHash": "db6e2e811f2480b0ceb0a6c8e2335dc59d23f7a3523dac538efa1f79fef8a30d",
      "noWriteIfExists": false
    },
    {
      "filename": "src/client.ts",
      "content": "/** The user accounts in the system */\nexport interface IUserAccount {\n    /** Unique identifier of the UserAccount */\n    id: string;\n    /** The username of the user account */\n    username: string;\n    /** The email address of the user account */\n    email: string;\n    /** The flags of the user account */\n    flags: string;\n}\n\nexport interface IUserAccountClient {\n    create(data: IUserAccount): Promise<void>;\n    update(data: IUserAccount): Promise<void>;\n    delete(data: IUserAccount): Promise<void>;\n    getById(id: string): Promise<IUserAccount>;\n    getAll(): Promise<IUserAccount[]>;\n}\n\nclass UserAccountClientImpl implements IUserAccountClient {\n    private baseUrl: string;\n\n    constructor(baseUrl: string) {\n        this.baseUrl = baseUrl;\n    }\n\n    async create(data: IUserAccount): Promise<void> {\n        const response = await fetch(`${this.baseUrl}/user-account`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n    }\n\n    async update(data: IUserAccount): Promise<void> {\n        const response = await fetch(`${this.baseUrl}/user-account/${data.id}`, {\n            method: 'PUT',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n    }\n\n    async delete(data: IUserAccount): Promise<void> {\n        const response = await fetch(`${this.baseUrl}/user-account/${data.id}`, {\n            method: 'DELETE',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n    }\n\n    async getById(id: string): Promise<IUserAccount> {\n        const response = await fetch(`${this.baseUrl}/user-account/${id}`);\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n        return response.json();\n    }\n\n    async getAll(): Promise<IUserAccount[]> {\n        const response = await fetch(`${this.baseUrl}/user-account`);\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n        return response.json();\n    }\n}\n/** The products in the system */\nexport interface IProduct {\n    /** Unique identifier of the Product */\n    id: string;\n    /** The name of the product */\n    name: string;\n    /** The price of the product */\n    price: number;\n    /** The description of the product */\n    description: string;\n}\n\nexport interface IProductClient {\n    create(data: IProduct): Promise<void>;\n    update(data: IProduct): Promise<void>;\n    delete(data: IProduct): Promise<void>;\n    getById(id: string): Promise<IProduct>;\n    getAll(): Promise<IProduct[]>;\n}\n\nclass ProductClientImpl implements IProductClient {\n    private baseUrl: string;\n\n    constructor(baseUrl: string) {\n        this.baseUrl = baseUrl;\n    }\n\n    async create(data: IProduct): Promise<void> {\n        const response = await fetch(`${this.baseUrl}/product`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n    }\n\n    async update(data: IProduct): Promise<void> {\n        const response = await fetch(`${this.baseUrl}/product/${data.id}`, {\n            method: 'PUT',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n    }\n\n    async delete(data: IProduct): Promise<void> {\n        const response = await fetch(`${this.baseUrl}/product/${data.id}`, {\n            method: 'DELETE',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n    }\n\n    async getById(id: string): Promise<IProduct> {\n        const response = await fetch(`${this.baseUrl}/product/${id}`);\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n        return response.json();\n    }\n\n    async getAll(): Promise<IProduct[]> {\n        const response = await fetch(`${this.baseUrl}/product`);\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n        return response.json();\n    }\n}\n\nexport interface IAppClient {\n    userAccount: IUserAccountClient;\n    product: IProductClient;\n}\n\nexport function createAppClient(baseUrl: string): IAppClient {\n    return {\n        userAccount: new UserAccountClientImpl(baseUrl),\n        product: new ProductClientImpl(baseUrl),\n    };\n}",
      "contentHash": "1e1166051d8423d764cb950328e7cfcd737d0658eb5336ab88ea39a14ad9007d",
      "noWriteIfExists": false
    },
    {
      "filename": "user-account.go",
      "content": "package main\n\nimport \"errors\"\n\ntype UserAccount struct {\n    Id string `json:\"id\"`\n    Username string `json:\"username\"`\n    Email string `json:\"email\"`\n    Flags []string `json:\"flags\"`\n}\n\ntype IUserAccountRepository interface {\n    Create(userAccount *UserAccount) error\n    Update(userAccount *UserAccount) error\n    Delete(userAccount *UserAccount) error\n    GetByID(id string) (*UserAccount, error)\n    GetAll() ([]UserAccount, error)\n}\n\ntype UserAccountRepository struct {\n    IUserAccountRepository\n    entities map[string]*UserAccount\n}\n\nfunc NewUserAccountRepository() *UserAccountRepository {\n    return &UserAccountRepository{\n        entities: make(map[string]*UserAccount),\n    }\n}\n\nfunc (repo *UserAccountRepository) Create(userAccount *UserAccount) error {\n    if _, ok := repo.entities[userAccount.Id]; ok {\n        return errors.New(\"UserAccount already exists\")\n    }\n    repo.entities[userAccount.Id] = userAccount\n    return nil\n}\n\nfunc (repo *UserAccountRepository) Update(userAccount *UserAccount) error {\n    if _, ok := repo.entities[userAccount.Id]; !ok {\n        return errors.New(\"UserAccount not found\")\n    }\n    repo.entities[userAccount.Id] = userAccount\n    return nil\n}\n\nfunc (repo *UserAccountRepository) Delete(userAccount *UserAccount) error {\n    if _, ok := repo.entities[userAccount.Id]; !ok {\n        return errors.New(\"UserAccount not found\")\n    }\n    delete(repo.entities, userAccount.Id)\n    return nil\n}\n\nfunc (repo *UserAccountRepository) GetByID(id string) (*UserAccount, error) {\n    if _, ok := repo.entities[id]; !ok {\n        return nil, errors.New(\"UserAccount not found\")\n    }\n    return repo.entities[id], nil\n}\n\nfunc (repo *UserAccountRepository) GetAll() ([]UserAccount, error) {\n    var result []UserAccount\n    for _, entity := range repo.entities {\n        result = append(result, *entity)\n    }\n    return result, nil\n}",
      "contentHash": "2413557c6a8516ddf43b7d74215414dcdfacb8c856df71a43a5f5121e10ea747",
      "noWriteIfExists": false
    }
  ]
}